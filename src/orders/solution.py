from typing import Dict, Optional, Any
from dataclasses import dataclass

from src.orders.intent import IntentData
from src.orders.quote import QuoteData

from src.utils.logging import exit_with_error

@dataclass
class SolutionData:
    """
    Represents a solution generated by an agent for a token swap.

    Attributes:
        solution_id (str): Unique identifier for the solution.
        source_token (str): Token being traded from the source.
        source_mint_address (str): Mint address for the source token.
        source_address (str): Address from which the source token is sent.
        source_amount (int): Amount of the source token.
        destination_token (str): Token received at the destination.
        destination_mint_address (str): Mint address for the destination token.
        destination_address (str): Address to which the destination token is sent.
        destination_amount (int): Amount of the destination token.
        route_plan (Optional[list[Dict[str, Any]]]): Route plan for the trade, if applicable.
    """

    solution_id: str
    source_token: str
    source_mint_address: str
    source_address: str
    source_amount: int
    destination_token: str
    destination_mint_address: str
    destination_address: str
    destination_amount: int
    route_plan: Optional[list[Dict[str, Any]]] = None

    def __init__(self, 
                 solution_id: str, 
                 source_token: str, 
                 source_mint_address: str, 
                 source_address: str, 
                 source_amount: int, 
                 destination_token: str, 
                 destination_mint_address: str,
                 destination_address: str,
                 destination_amount: int,
                 route_plan: Optional[list[Dict[str, Any]]] = None):
        """
        Initialize the SolutionData object with the provided parameters.

        Args:
            solution_id (str): Unique identifier for the solution.
            source_token (str): Token being sent.
            source_mint_address (str): Mint address for the source token.
            source_address (str): Address from which the source token is sent.
            source_amount (int): Amount of the source token.
            destination_token (str): Token being received.
            destination_mint_address (str): Mint address for the destination token.
            destination_address (str): Address to which the destination token is sent.
            destination_amount (int): Amount of the destination token.
            route_plan (Optional[list[Dict[str, Any]]], optional): The route plan for the trade. Defaults to None.
        """
        self.solution_id = solution_id
        self.source_token = source_token
        self.source_mint_address = source_mint_address
        self.source_address = source_address
        self.source_amount = source_amount
        self.destination_token = destination_token
        self.destination_mint_address = destination_mint_address
        self.destination_address = destination_address
        self.destination_amount = destination_amount
        self.route_plan = route_plan if route_plan else {}

    @classmethod
    def from_intent_match(cls, intent_a: 'IntentData', intent_b: 'IntentData') -> tuple['SolutionData', 'SolutionData']:
        """
        Create and return solutions for a peer-to-peer (P2P) trade based on matching intents.

        Args:
            intent_a (IntentData): The first intent in the match.
            intent_b (IntentData): The second intent in the match.

        Returns:
            SolutionData, SolutionData: two SolutionData objects representing the trade from each intent's perspective.
        """
        solution_a = cls(
            solution_id='---',
            source_token=intent_a.source_token,
            source_mint_address=intent_a.source_mint_address,
            source_address=intent_a.source_address,
            source_amount=intent_a.source_amount,
            destination_token=intent_a.destination_token,
            destination_mint_address=intent_a.destination_mint_address,
            destination_address=intent_b.source_address,
            destination_amount=intent_b.source_amount
        )
        solution_b = cls(
            solution_id='---',
            source_token=intent_b.source_token,
            source_mint_address=intent_b.source_mint_address,
            source_address=intent_b.source_address,
            source_amount=intent_b.source_amount,
            destination_token=intent_b.destination_token,
            destination_mint_address=intent_b.destination_mint_address,
            destination_address=intent_a.source_address,
            destination_amount=intent_a.source_amount
        )
        return solution_a, solution_b
    
    @classmethod
    def from_quote(cls, quote: 'QuoteData', intent: 'IntentData') -> 'SolutionData':
        """
        Create a SolutionData object based on a quote for an intent.

        Args:
            quote (QuoteData): The quote data object.
            intent (IntentData): The intent data object.

        Returns:
            SolutionData: The solution data object created from the quote and intent.

        Raises:
            ValueError: If the quote's input or output mint does not match the intent or if the output amount is less than the minimum receive amount.
        """
        # Sanity checks
        if (quote.input_mint != intent.source_mint_address):
            exit_with_error(f"Quote's input mint does not match source token in intent {intent.intent_id}.")
        if (quote.output_mint != intent.destination_mint_address):
            exit_with_error(f"Quote's output mint does not match destination token in intent {intent.intent_id}.")
        if (int(quote.out_amount) < intent.min_receive_amount):
            exit_with_error(f'Quote for intent {intent.intent_id} provides less {intent.destination_token} than the minimum required {intent.min_receive_amount}.')
        
        # Initialize solution
        solution = cls(
            solution_id='---',
            source_token=intent.source_token,
            source_mint_address=intent.source_mint_address,
            source_address=intent.source_address,
            source_amount=intent.source_amount,
            destination_token=intent.destination_token,
            destination_mint_address=intent.destination_mint_address,
            destination_address=intent.destination_address,
            destination_amount=quote.out_amount,
            route_plan=quote.route_plan
        )
        return solution
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Convert the SolutionData object to a dictionary.

        Returns:
            Dict[str, Any]: The dictionary representation of the SolutionData object.
        """
        return {
            "solution_id": self.solution_id,
            "source_token": self.source_token,
            "source_mint_address": self.source_mint_address,
            "source_address": self.source_address,
            "source_amount": self.source_amount,
            "destination_token": self.destination_token,
            "destination_mint_address": self.destination_mint_address,
            "destination_address": self.destination_address,
            "destination_amount": self.destination_amount,
            "route_plan": self.route_plan
        }
